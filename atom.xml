<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whatswater.github.io</id>
    <title>技术笔记</title>
    <updated>2020-04-01T14:08:54.196Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whatswater.github.io"/>
    <link rel="self" href="https://whatswater.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://whatswater.github.io/images/avatar.png</logo>
    <icon>https://whatswater.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 技术笔记</rights>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（1）- 序]]></title>
        <id>https://whatswater.github.io/post/hello-gridea/</id>
        <link href="https://whatswater.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>前言</strong><br>
我在编程的过程中，碰到不懂的地方，总是喜欢在网络上搜索答案，先解决问题再说。碰到的次数多了，总这么做心里就隐隐有些不爽：每次都要从网络上筛选大量的信息，不确定选择的解决办法是不是最优的，于是到处看来看去，管中窥豹，期望能够对这个地方稍有了解。几日不见这种问题，多日之后再碰到，又要再搜索。究其原因，则是在解决问题时偷懒，不去思考问题，同时也没有记录笔记。于是乎便有了这个博客，一是作为笔记帮我快速的查找；二是把某个领域的知识体系融入到我现有的体系中。<br>
<strong>并发编程系列目标</strong><br>
此系列主要是JAVA并发编程的一些笔记，包括</p>
<ul>
<li>JAVA并发的基础知识：JAVA内存模型、线程安全和隔离级别、先行发生原则、线程安全的实现手段、JVM锁优化策略</li>
<li>并发编程的常用技巧：如何设计数据结构缩小互斥操作的范围、各种同步手段的使用技巧、悲观和乐观策略的抉择、如何确定对象需要什么样的线程安全和隔离级别</li>
<li>如何证明线程安全<br>
本系列只讨论有竞态条件的情况，异步、TheadLocal、线程池这种实际上单线程的不讨论。</li>
</ul>
<pre><code class="language-java">    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>
<p>先使用CAS操作HEAD，多线程同时操作时，只有一个能成功，所以<code>tail = head;</code>操作是单线程执行。<code>tail = head;</code>刚好影响了<code>t == null</code>的判断（tail属性有volatile修饰符），所以不会有其他线程在<code>compareAndSetHead(new Node())</code>刚执行完<code>tail = head;</code>未执行时进入<code>t != null</code>的分支，在<code>t == null</code>的分支执行<code>compareAndSetHead(new Node())</code>必然失败，然后继续循环。</p>
]]></content>
    </entry>
</feed>