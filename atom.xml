<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whatswater.github.io</id>
    <title>技术笔记</title>
    <updated>2020-04-05T14:05:08.075Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whatswater.github.io"/>
    <link rel="self" href="https://whatswater.github.io/atom.xml"/>
    <subtitle>好，很好，非常好</subtitle>
    <logo>https://whatswater.github.io/images/avatar.png</logo>
    <icon>https://whatswater.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 技术笔记</rights>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（4）- 线程安全]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-4-xian-cheng-an-quan-ji-bie/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-4-xian-cheng-an-quan-ji-bie/">
        </link>
        <updated>2020-04-04T13:51:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>线程安全级别</strong><br>
    线程安全并没有一个准确的定义，到底线程安全是什么，应该提供什么样的保证。为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下4类：不可变、相对线程安全、线程兼容和线程对立。</p>
<ul>
<li>不可变<br>
对象创建之后就不可变。由于对象本身不可变，所以调用对象的任何方法都不会有线程安全问题。</li>
<li>相对线程安全<br>
相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li>
<li>线程兼容<br>
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</li>
<li>线程对立<br>
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。<br>
一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System.setIn()、Sytem.setOut()和System.runFinalizersOn-Exit()等。线程对立的代码，只能在一个线程中执行。</li>
</ul>
<p><strong>隔离级别</strong><br>
    线程安全并不意味着在这个对象上的操作可以看成是串行的。对这个对象的单个操作可能会改动对象内部多个状态，直到关键的一个状态修改后，这个操作才生效。这样可能导致调用顺序和实际生效的顺序不一致。当一个线程执行一个修改操作，然后另外一个线程执行一个读取操作，但是修改操作还未完成，读取操作已经执行完毕，读取操作读到了未修改之前的状态。实际上是先执行了读取操作，后执行修改操作。两个并行的修改操作也可能会产生这种问题。<br>
    对象内部也可能存在一些冗余状态，为了提高并发时性能，这些冗余状态的更新和主要状态的更新没必要做成原子性的操作。举一个简单的例子，一个单链表中存储了链表的大小，执行添加操作时，分成两个原子性的操作：将元素添加到链表中；自增链表的大小。另外一个线程读取的时候，可能元素已经添加到链表中，但是链表大小还没变化。但是对象提供了遍历和获取大小的API，这两个API看到的状态就不一样。<br>
<img src="https://whatswater.github.io/post-images/1586095496177.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（3）- 先行发生原则]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-3/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-3/">
        </link>
        <updated>2020-04-04T13:12:20.000Z</updated>
        <content type="html"><![CDATA[<p>    JAVA内存模型描述非常的难懂，一般使用等价的先行发生原则来判断线程安全。先行发生时java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之间，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。<br>
    JAVA内存模型中存在着一些“天然的”先行发生关系。。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>    先行发生不一定是时间上的先行发生，而是逻辑上的先行发生。对于管程锁定规则和volatile变量规则来讲（多个线程的竞争操作），逻辑上的先行发生就是时间上的先行发生。<br>
    先行发生原则中比较常见的是“管程锁定规则”和“volatile变量规则”，“管程锁定规则”可以简单的理解为加锁和解锁是串行的；“volatile变量规则”可以简单理解为volatile变量的写入和读取之间是串行的，写入和写入之间是串行的，读取和读取之间是并行的（PS：很像读写锁）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（2）- JAVA内存模型]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-2-java-nei-cun-mo-xing/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-2-java-nei-cun-mo-xing/">
        </link>
        <updated>2020-04-02T13:47:11.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简介</strong><br>
    现代CPU存在多级缓存和乱序执行，编译器也有指令重排序优化，在并发环境下，会导致缓存不一致等问题。JAVA内存模型是一个关于并发访问内存的规范，此规范屏蔽了各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。<br>
<strong>内存模型定义</strong><br>
    JAVA内存模型将内存划分为主内存和工作内存，所有的变量都存在主内存中，工作内存是每个线程的缓存。JAVA内存模型规定了8种操作在主内存和工作内存中传递变量。</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>    如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<p><strong>简化版本</strong><br>
    上述规则太多且太复杂，所以我整理了一个简单的版本。JAVA内存模型可以分为两部分：lock、内存同步。<br>
  内存同步部分可以精简为以下三条规则：</p>
<ul>
<li>对于单个变量，可以认为read、load（主内存读取到工作内存）和store、write（工作内存同步到主内存）是一个原子操作。</li>
<li>变量必须在主内存中创建；对变量的更改只能由执行引擎触发。</li>
<li>若工作内存发生更改，则最后的更改必须同步回主内存；若工作内存未发生更改，则不能同步回主内存。</li>
</ul>
<p>  lock部分可以精简为两条原则：</p>
<ul>
<li>一个变量同一时刻只有一个线程能执行lock操作，只有获取到lock的线程才能执行unlock；同一个线程对同一个变量可以多次执行lock，需要执行同样次数的unlock操作才能解锁。</li>
<li>对一个变量执行lock操作，会清空这个变量在工作内存中的值。对一个变量执行unlock操作之前，必须现把变量同步回主内存中。（如果一个线程执行了lock，清空了变量，另外一个线程的执行引擎执行了assign，会怎样？）</li>
</ul>
<p><strong>volatile</strong><br>
    volatile修饰的变量有特殊的规则：</p>
<ul>
<li>对于单个volatile变量，可以认为read、load、use是一个原子操作，assign、store、write是一个原子操作。这条规则保证了volatile变量每次均从主内存中读，写入时直接写入主内存。</li>
<li>禁止指令重排序：对volatile修饰的变量赋值时，赋值操作之前的指令要全部执行完毕，赋值操作之后的指令均未执行。</li>
</ul>
<p><strong>volatile的理解</strong><br>
    对volatile修饰的变量赋值时，赋值操作会引发assign、store、write操作，这些操作会使其他CPU核心的缓存失效，同时执行store/write操作时，之前的指令要全部执行完毕，之后的指令均未执行。<br>
    volatile仅保证可见性，只适用于很少的情况。如果一个变量正在执行引擎中use时被其他线程更新了，这时执行引擎中的还是老的变量，仅使用volatile没法保证线程安全。<br>
仅使用volatile就能保证线程安全的情况如下：运算结果并不依赖变量的当前值或者能够保证只有单一的线程修改变量的值，而且这种情况下也只是对这一个变量的线程安全，若有多个变量表示一种状态，仅使用volitale同步是不行的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（1）- 序]]></title>
        <id>https://whatswater.github.io/post/concurrent_index/</id>
        <link href="https://whatswater.github.io/post/concurrent_index/">
        </link>
        <updated>2020-04-01T14:20:33.000Z</updated>
        <content type="html"><![CDATA[<p><strong>前言</strong><br>
我在编程的过程中，碰到不懂的地方，总是喜欢在网络上搜索答案，先解决问题再说。碰到的次数多了，总这么做心里就隐隐有些不爽：每次都要从网络上筛选大量的信息，不确定选择的解决办法是不是最优的，于是到处看来看去，管中窥豹，期望能够对这个地方稍有了解。几日不见这种问题，多日之后再碰到，又要再搜索。究其原因，则是在解决问题时偷懒，不去思考问题，同时也没有记录笔记。于是乎便有了这个博客，一是作为笔记帮我快速的查找；二是把某个领域的知识体系融入到我现有的体系中。<br>
<strong>并发编程系列目标</strong><br>
此系列主要是JAVA并发编程的一些笔记，包括</p>
<ul>
<li>JAVA并发的基础知识：JAVA内存模型、线程安全和隔离级别、先行发生原则、线程安全的实现手段、JVM锁优化策略</li>
<li>并发编程的常用技巧：如何设计数据结构缩小互斥操作的范围、各种同步手段的使用技巧、悲观和乐观策略的抉择、如何确定对象需要什么样的线程安全和隔离级别</li>
<li>如何证明线程安全<br>
本系列只讨论有竞态条件的情况，异步、TheadLocal、线程池这种实际上单线程的不讨论。</li>
</ul>
<pre><code class="language-java">    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>
<p>先使用CAS操作HEAD，多线程同时操作时，只有一个能成功，所以<code>tail = head;</code>操作是单线程执行。<code>tail = head;</code>刚好影响了<code>t == null</code>的判断（tail属性有volatile修饰符），所以不会有其他线程在<code>compareAndSetHead(new Node())</code>刚执行完<code>tail = head;</code>未执行时进入<code>t != null</code>的分支，在<code>t == null</code>的分支执行<code>compareAndSetHead(new Node())</code>必然失败，然后继续循环。</p>
]]></content>
    </entry>
</feed>