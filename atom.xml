<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whatswater.github.io</id>
    <title>技术笔记</title>
    <updated>2020-04-06T14:29:18.765Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whatswater.github.io"/>
    <link rel="self" href="https://whatswater.github.io/atom.xml"/>
    <subtitle>好，很好，非常好</subtitle>
    <logo>https://whatswater.github.io/images/avatar.png</logo>
    <icon>https://whatswater.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 技术笔记</rights>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（12）- 简易MVCC实现]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-11-jian-yi-mvcc-shi-xian/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-11-jian-yi-mvcc-shi-xian/">
        </link>
        <updated>2020-04-05T14:35:58.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（11）- ImmutableJs源码解析]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-11-mvcc-shi-xian/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-11-mvcc-shi-xian/">
        </link>
        <updated>2020-04-05T14:35:58.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（10）- JUC包源码解析]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-10-juc-bao-yuan-ma-jie-xi/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-10-juc-bao-yuan-ma-jie-xi/">
        </link>
        <updated>2020-04-05T14:35:27.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（9）- 线程安全实现策略和技巧]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-9-xian-cheng-an-quan-shi-xian-ce-lue-he-ji-qiao/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-9-xian-cheng-an-quan-shi-xian-ce-lue-he-ji-qiao/">
        </link>
        <updated>2020-04-05T14:34:32.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（8）- 线程安全单链表实现]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-8-xian-cheng-an-quan-dan-lian-biao-shi-xian/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-8-xian-cheng-an-quan-dan-lian-biao-shi-xian/">
        </link>
        <updated>2020-04-05T14:33:52.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（7）- JUC包]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-7-juc-bao/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-7-juc-bao/">
        </link>
        <updated>2020-04-05T14:33:17.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（6）- CAS、锁、锁优化]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-6-cassuo-suo-you-hua/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-6-cassuo-suo-you-hua/">
        </link>
        <updated>2020-04-05T14:31:29.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（5）- 线程状态变化和中断处理]]></title>
        <id>https://whatswater.github.io/post/java-duo-xian-cheng-bian-cheng-5-xian-cheng-zhuang-tai-bian-hua-he-zhong-duan-chu-li/</id>
        <link href="https://whatswater.github.io/post/java-duo-xian-cheng-bian-cheng-5-xian-cheng-zhuang-tai-bian-hua-he-zhong-duan-chu-li/">
        </link>
        <updated>2020-04-05T14:30:33.000Z</updated>
        <content type="html"><![CDATA[<p><strong>线程实现</strong><br>
    线程实现包括线程实现和线程调度。线程实现分为：1、用户态线程；2、操作系统提供的线程；3、M:N模式，一般JVM使用的是操作系统提供的线程。线程调度方式分为：抢占式和协同式，大部分JVM实现的是抢占式调度。</p>
<p><strong>线程状态转换</strong><br>
JAVA语言定义了5种线程状态，在任意一个时间点，一个线程有且只有其中一个状态，这5个状态分别如下：</p>
<ol>
<li>新建（New），创建后尚未启动的线程处于这种状态</li>
<li>运行（Runnale），Runnable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</li>
<li>无限期等待（Waiting），处于这种状态的线程不会被分配CPU执行时间，他们要等待被其他线程显示地唤醒。以下方法会让线程陷入无限期等待状态：
<ul>
<li>没有设置Timeout参数的Object.wait()方法。</li>
<li>没有设置Timeout参数的Thread.join方法。</li>
<li>LockSupport.park()方法。</li>
</ul>
</li>
<li>限期等待（Timed waiting），处于这种状态的线程也不会被CPU分配执行时间，不过无须等待被其他线程显示唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
<ul>
<li>Thread.sleep()方法。</li>
<li>设置了Timeout参数的Object.wait()方法。</li>
<li>设置了Timeout参数的Thread.join()方法。</li>
<li>LockSupport.parkNanos()方法。</li>
<li>LockSupport.parkUntil()方法。</li>
</ul>
</li>
<li>阻塞(Blocked)，线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作发生。在程序等待进入同步区域时，线程将进入这种状态。</li>
<li>结束（Terminated），已终止线程的线程状态，线程已结束执行。</li>
</ol>
<p><strong>EntryList、WaitSet</strong><br>
    针对每个需要加锁的对象，JVM内部维护了两个队列：EntryList和WaitSet。EntryList用于存储正在竞争锁的线程，当这个对象解锁后，其中的一个线程会获取锁；WaitSet用于存储处于等待状态的线程，这些线程在满足唤醒条件的事件发生时（notify、超时等），会转移到EntryList中参与锁的竞争。<br>
    对于操作系统来讲，线程处于wait状态或者blocked状态都是一样的，都是暂停执行，没啥本质的区别。一个线程调用了同步IO，线程也会被操作系统阻塞起来。这些状态区别就在于恢复执行时候的触发条件不同：处于wait状态的线程需要wait对象执行notify、notifyAll或者wait超时，然后变成blocked状态；处于blocked状态的线程需要获取到锁，才可恢复执行；被IO阻塞的线程需要等待IO事件完成，才可恢复执行。wait状态和blocked状态是JVM管理的（EntryList、WaitSet）而IO阻塞是操作系统管理的。</p>
<p><strong>线程协作常用方法</strong></p>
<ul>
<li>object.wait()，此方法是Object类中的native方法。假定在对象object上调用wait方法，会让当前线程暂时性的释放对object的锁（调用此方法前需要保证当前线程已兢获取到对object的锁）。当前线程会被放入object的WaitSet中。</li>
<li>object.notify()，此方法是Object类中的native方法，调用此方法会在object的WaitSet中随机选取一个线程，把这个线程转移到EntryList中。</li>
<li>object.notifyAll()，此方法是Object类中的native方法，调用此方法会讲object的WaitSet中所有线程转移到EntryList中。</li>
<li>thread.join，实例方法，调用后当前线程会处于wait状态，等待调用的线程之心完毕。</li>
<li>Thread.sleep，静态方法，使当前线程睡眠一段时间。</li>
<li>JUC包</li>
</ul>
<p><strong>处理中断</strong><br>
https://zhuanlan.zhihu.com/p/27857336，每种线程状态对中断的响应是什么？什么操作会导致线程中断？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（4）- 线程安全]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-4-xian-cheng-an-quan-ji-bie/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-4-xian-cheng-an-quan-ji-bie/">
        </link>
        <updated>2020-04-04T13:51:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>线程安全级别</strong><br>
    线程安全并没有一个准确的定义，到底线程安全是什么，应该提供什么样的保证。为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待，按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下4类：不可变、相对线程安全、线程兼容和线程对立。</p>
<ul>
<li>不可变<br>
对象创建之后就不可变。由于对象本身不可变，所以调用对象的任何方法都不会有线程安全问题。</li>
<li>相对线程安全<br>
相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li>
<li>线程兼容<br>
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</li>
<li>线程对立<br>
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。<br>
一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System.setIn()、Sytem.setOut()和System.runFinalizersOn-Exit()等。线程对立的代码，只能在一个线程中执行。</li>
</ul>
<p><strong>隔离级别</strong><br>
    隔离级别是我学习JAVA并发编程时生造的一个概念，借鉴自数据库的隔离级别概念。在JAVA并发编程中，隔离级别指的是对一个对象的并发操作，单个操作的结果什么时候会影响到其他操作，大致可分为以下三种：串行、读已提交、读未提交。串行指的是对对象的操作都可看作是串行的，一个操作执行完毕后再执行另外一个操作；读已提交指的是单个操作执行完毕后，只有在最终提交时才会影响到其他操作，但是多个操作之间的顺序不能保证；读未提交指的是单个操作执行时，中途会多次提交修改，其他操作能够读到中间状态，其他操作需要处理这些中间状态。对线程安全的对象最低要求是多线程并发时内部状态不会被破坏，所以‘读未提交’是可以的。<br>
    相对线程安全并不意味着其隔离级别就是串行的。对某个对象的单个操作，可能执行较长的时间，直到关键的一个状态修改后，这个操作才会生效。在这个操作执行过程中，后执行的其他操作可能先于这个操作执行完毕，调用顺序和实际生效的顺序不一致。当一个线程执行一个修改操作，然后另外一个线程执行一个读取操作，但是修改操作还未完成，读取操作已经执行完毕，读取操作读到了未修改之前的状态，两个并行的修改操作也可能会存在这种顺序问题。<br>
    对象内部也可能存在多个状态，为了提高并发时性能，这些状态时并不是原子性的。举一个简单的例子，一个单链表中存储了链表的大小，执行添加操作时，分成两个原子性的操作：将元素添加到链表中；自增链表的大小。另外一个线程读取的时候，可能元素已经添加到链表中，但是链表大小还没变化。对象提供了遍历和获取大小的API，这两个API看到的状态就不一致。<br>
<img src="https://whatswater.github.io/post-images/1586095496177.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA并发编程系列（3）- 先行发生原则]]></title>
        <id>https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-3/</id>
        <link href="https://whatswater.github.io/post/java-bing-fa-bian-cheng-xi-lie-3/">
        </link>
        <updated>2020-04-04T13:12:20.000Z</updated>
        <content type="html"><![CDATA[<p>    JAVA内存模型描述非常的难懂，一般使用等价的先行发生原则来判断线程安全。先行发生时java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之间，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。<br>
    JAVA内存模型中存在着一些“天然的”先行发生关系。。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>    先行发生不一定是时间上的先行发生，而是逻辑上的先行发生。对于管程锁定规则和volatile变量规则来讲（多个线程的竞争操作），逻辑上的先行发生就是时间上的先行发生。<br>
    先行发生原则中比较常见的是“管程锁定规则”和“volatile变量规则”，“管程锁定规则”可以简单的理解为加锁和解锁是串行的；“volatile变量规则”可以简单理解为volatile变量的写入和读取之间是串行的，写入和写入之间是串行的，读取和读取之间是并行的（PS：很像读写锁）。</p>
]]></content>
    </entry>
</feed>